setup:
1. install sqlexplorer plugin in eclipse (need to install JBoss Tools plugin to do that)
2. Create hibernate user library with provided jars and add it to build path
3. New -> Hibernate -> Hibernate Configuration File (cfg.xml) -> Next -> Give a name for configuration file -> Get values from connection -> New -> Select regarding option -> 
Add jdbc driver for the specific database in plus symbol window's jar list tab -> Add connection properties like database, url && etc -> Test connection -> if ping succeeded next and 
file is there

(hibernate.cfg.xml : default name for hibernate configuration file, no need to tell hibernate about name of the configuration file if this name is used)

only one session factory per application

 <!-- Drop and re-create the database schema on startup -->
        <property name="hbm2ddl.auto">create</property>
is handy when need to do many changes in schema (while developing)

<property name="hbm2ddl.auto">update</property> : there is a model change -> update

<property name="show_sql">true</property> : to print SQL queries in console

@Entity (name="TABLE_USER_DETAILS") is useful need to have different name for table from class or the other way round

@Column(name = "COLUMN_USER_NAME") is useful need to have different name for column from attribute or the other way round

It is allowed to have @Column annotation on top of getter method instead for having it on top of the attribute

@Entity(name = "TABLE_USER_DETAILS_BY_ENTITY") vs @Table(name = "TABLE_USER_DETAILS_BY_TABLE"): entity is shown as TABLE_USER_DETAILS_BY_ENTITY and
actual table name is set as TABLE_USER_DETAILS_BY_TABLE

@Basic is used to tell hibernate that specific attribute is persistable. By default for all attribute @Basic will be there

static or transient attribute will not be saved

attribute annotated with @Transient will not be saved

@Temporal(value = TemporalType.DATE) : to save only date part(@Temporal(value = TemporalType.TIMESTAMP) is the default)

@Lob
private String description; : Large object - CLob : character large object, BLob : Byte large object (Hibernate chooses which type needs to be selected based on the
type of the attribute (String - CLob, byte - BLob)

Natural key : unique column is used as primary key, which has a business significant
Surrogate key : no business significant. dedicated to uniquely identify a record

If a key is a surrogate key, hibernate is able to handle that. @GeneratedValue is used for that. (Insight: hibernate is maintaining a sequence and use that to
generate value)
strategy=GenerationType.AUTO : let hibernate to decide the strategy to generate primary key

------------------------------------------------------------------------------------------------

one attribute -> multiple column (Eg: An attribute is an object or an attribute is a collection)

Entity vs Value objects: Entity : needs to be saved in a separate table (UserDetails)
Value objects: not have meaning itself. depend on another object (Address)

value objects are saved along with entity with separate columns for them : value object needs to be marked as @Embeddable in the class name, @Embedded in the 
attribute name in another class.

Having multiple value object with same type:
Exception in thread "main" org.hibernate.MappingException: Repeated column in mapping for entity: org.jeya.dto.UserDetails column: COLUMN_CITY 
(should be mapped with insert="false" update="false")

Solution: override column name for other attributes
@AttributeOverride is used. Multiple @AttributeOverride are kept inside @AttributeOverrides

Embedded object as a primary key : annotate that attribute with @EmbeddedId

**************************************************************************************************

Collection of object as attribute:

separate table of collection and associated with user id

@ElementCollection is annotated above the attribute with collection type

@JoinTable(name="USER_ADDRESS",
			joinColumns=@JoinColumn(name="USER_ID")) to have different name for joint table and column to join

@CollectionId is used to have primary key for joint table for collection : hibernate specific annotation: unavailable in JPA

Eager initialization vs Lazy initialization:
Eager initialization - When Session.get() all the addresses will be fetched for user details.
Lazy initialization - When userDetails.getListOfAddresses is invoked only addresses will be loaded. (default behavior)

when getter is invoked data is load. It is done by a proxy class. subclass of user details is created as proxy and second level of database operation is done
in proxy class when getter is invoked.
********************************************************************************************************

One to one mapping:
one entity inside another entity:
(Difference between value objects (simple Address) and UserDetails Vs Vehicle and UserDetails: Address has no significant without UserDetails, Vehicle is independent. Separate entity:
see <mapping class="org.jeya.dto.Vehicle" /> is not available for Address and address is not saved separately)

When there is no @OneToOne annotation in vehicle attribute:
Exception in thread "main" org.hibernate.MappingException: Could not determine type for: org.jeya.dto.Vehicle, at table: TABLE_USER_DETAILS5_BY_TABLE, for columns:
[org.hibernate.mapping.Column(vehicle)]

It is looking for a connection between both entities.
@OneToOne will add extra column in UserDetails table (vehicle_vehicleid)

*********************************************************************************************************

One to many mapping:
UserDetails with collection of vehicle. Create separate table to have  the relationship between vehicle and user details
@OneToMany annotation is used
----------------------------------------------------------------------------------------------------------------------- 